# what is OCF
## C++のクラスにおいて、リソース管理を適切に行うために推奨される特別メンバ関数（デストラクタ、コピーコンストラクタ、コピー代入演算子、ムーブコンストラクタ、ムーブ代入演算子）の実装ガイドラインを指します

1. デストラクタ :objectが破棄される際に、割り当てられたリソースを解放します
```
~ClassName() {
    // クリーンアップコード
}
```
2. コピーコンストラクタ :他のオブジェクトのコピーとして新しいオブジェクトを作成します
```
ClassName(const ClassName& other) {
    // コピーコード
}
```
3. コピー代入演算子 :既存のオブジェクトに他のオブジェクトの状態を代入します
```
ClassName& operator=(const ClassName& other) {
    if (this != &other) {
        // クリーンアップコード
        // コピーコード
    }
    return *this;
}
````

4. デフォルトコンストラクタ	:デフォルトコンストラクタは、クラスのオブジェクトが生成される際に適切な初期状態にするために使用されます 

5. ムーブコンストラクター :c++11以降らしい

6. ムーブ代入演算子 :同上

## RAII
コンストラクタで必要なメモリを確保してデストラクターで解放すること

## コンストラクタの種類
コンストラクタにはプログラマが書いたユーザ定義コンストラクタの他にコンパイラが自動で生成するユーザ定義コンストラクタがある
コンパイラ生成コンストラクタの中にはクラスをコピーする際に使われるコピーコンストラクタがある


## コピーコンストラクタ
 多くの場合、コンパイラが作成するコピーコンストラクタで問題ないが、コピー対象のクラスがメモリやリソース領域を扱う場合
ポインタ変数の値のみをコピーし、ポインターの指す実際のオブジェクトはコピーしない
オブジェクトが１つしか存在しないのに複数のクラスで同じアドレスを持ってしまいdouble freeとなる

## constメンバー関数
クラスはメンバー変数や関数を用いてさまざまな機能をクラスの外部に提供できます
しかし、メンバー関数がメンバー変数を変更するかどうかはいっけん見ただけではわからない
コンパイラは基本的にメンバー関数をメンバー変数を変更するものとして扱う
そのためconstなインスタンスに対するメンバー関数の呼び出しをエラーとして処理する
しかし、getterなどの本来メンバー変数を変更しない関数は呼び出したいのでconstメンバー関数をつかってよびだせる

```
class a
{
public:
	return-type menber-function(param...) const;
}

return-type class-name::member-function-name(param...) const
{
	function-body...
}
```

関数のオーバーロードで引数の違いと同様に関数がconstかどうかでメンバー関数のオーバーロードを定義できる
どちらの関数が呼ばれるかはインスタンスがconstかどうかによる

## 演算子オーバーロード
## thisポインタ
## static
## 固定小数点
